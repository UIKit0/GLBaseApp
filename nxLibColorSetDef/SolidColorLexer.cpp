/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : SolidColor.g
 *     -                            On : 2011-09-23 20:02:22
 *     -                 for the lexer : SolidColorLexerLexer *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

// @lexer::header
#define ANTLR3_INLINE_INPUT_UTF16

#include <d2d1.h>
#include <iostream>
#include "nx/color/SolidColor.h"
#include "nx/color/internal/Utils.h"
using namespace nx::color;
using namespace nx::color::internal;

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SolidColorLexer.h"
/* ----------------------------------------- */


/** String literals used by SolidColorLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR lit_1[]  = { 0x72, 0x67, 0x62, 0x61, 0x28,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_2[]  = { 0x68, 0x73, 0x62, 0x61, 0x28,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_3[]  = { 0x30, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_4[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_5[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR lit_6[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define     CTX ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define SCOPE_TYPE(scope)   pSolidColorLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSolidColorLexer_##scope##Stack
#define SCOPE_TOP(scope)    ctx->pSolidColorLexer_##scope##Top
#define SCOPE_SIZE(scope)       ctx->pSolidColorLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)    (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef      LEXER
#undef      RECOGNIZER
#undef      RULEMEMO
#undef      GETCHARINDEX
#undef      GETLINE
#undef      GETCHARPOSITIONINLINE
#undef      EMIT
#undef      EMITNEW
#undef      MATCHC
#undef      MATCHS
#undef      MATCHRANGE
#undef      LTOKEN
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      INPUT
#undef      STRSTREAM
#undef      LA
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      LRECOVER
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      BACKTRACKING
#undef      MATCHANY
#undef      MEMOIZE
#undef      HAVEPARSEDRULE
#undef      GETTEXT
#undef      INDEX
#undef      SEEK
#undef      PUSHSTREAM
#undef      POPSTREAM
#undef      SETTEXT
#undef      SETTEXT8

#define     LEXER                   ctx->pLexer
#define     RECOGNIZER              LEXER->rec
#define     LEXSTATE                RECOGNIZER->state
#define     TOKSOURCE               LEXSTATE->tokSource
#define     GETCHARINDEX()          LEXER->getCharIndex(LEXER)
#define     GETLINE()               LEXER->getLine(LEXER)
#define     GETTEXT()               LEXER->getText(LEXER)
#define     GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define     EMIT()                  LEXSTATE->type = _type; LEXER->emit(LEXER)
#define     EMITNEW(t)              LEXER->emitNew(LEXER, t)
#define     MATCHC(c)               LEXER->matchc(LEXER, c)
#define     MATCHS(s)               LEXER->matchs(LEXER, s)
#define     MATCHRANGE(c1,c2)       LEXER->matchRange(LEXER, c1, c2)
#define     MATCHANY()              LEXER->matchAny(LEXER)
#define     LTOKEN                  LEXSTATE->token
#define     HASFAILED()             (LEXSTATE->failed == ANTLR3_TRUE)
#define     BACKTRACKING            LEXSTATE->backtracking
#define     FAILEDFLAG              LEXSTATE->failed
#define     INPUT                   LEXER->input
#define     STRSTREAM               INPUT
#define     ISTREAM                 INPUT->istream
#define     INDEX()                 ISTREAM->index(ISTREAM)
#define     SEEK(n)                 ISTREAM->seek(ISTREAM, n)
#define     EOF_TOKEN               &(LEXSTATE->tokSource->eofToken)
#define     HASEXCEPTION()          (LEXSTATE->error == ANTLR3_TRUE)
#define     EXCEPTION               LEXSTATE->exception
#define     CONSTRUCTEX()           RECOGNIZER->exConstruct(RECOGNIZER)
#define     LRECOVER()              LEXER->recover(LEXER)
#define     MARK()                  ISTREAM->mark(ISTREAM)
#define     REWIND(m)               ISTREAM->rewind(ISTREAM, m)
#define     REWINDLAST()            ISTREAM->rewindLast(ISTREAM)
#define     MEMOIZE(ri,si)          RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define     HAVEPARSEDRULE(r)       RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define     PUSHSTREAM(str)         LEXER->pushCharStream(LEXER, str)
#define     POPSTREAM()             LEXER->popCharStream(LEXER)
#define     SETTEXT(str)            LEXSTATE->text = str
#define     SKIP()                  LEXSTATE->token = &(TOKSOURCE->skipToken)
#define     USER1                   LEXSTATE->user1
#define     USER2                   LEXSTATE->user2
#define     USER3                   LEXSTATE->user3
#define     CUSTOM                  LEXSTATE->custom
#define     RULEMEMO                LEXSTATE->ruleMemo
#define     DBG                     RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define       NEXTCHAR    ((pANTLR3_UINT8)(INPUT->nextChar))
#  define       DATAP   ((pANTLR3_UINT8)(INPUT->data))

# else

#  define       NEXTCHAR    ((pANTLR3_UINT16)(INPUT->nextChar))
#  define       DATAP   ((pANTLR3_UINT16)(INPUT->data))

# endif

# define        LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define     CONSUME()   INPUT->istream->consume(INPUT->istream)
#define     LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define     TOKTEXT(tok, txt)               tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define     UP      ANTLR3_TOKEN_UP
#define     DOWN    ANTLR3_TOKEN_DOWN
#define     EOR     ANTLR3_TOKEN_EOR
#define     INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void  mT__15    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mT__16    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mT__17    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mT__18    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mID    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mHEXINT    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mFLOAT    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mCOMMENT    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mWS    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mSTRING    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mEXPONENT    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mHEX_DIGIT    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mESC_SEQ    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mOCTAL_ESC    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mUNICODE_ESC    (pSolidColorLexer ctx);
static ANTLR3_INLINE  void  mTokens    (pSolidColorLexer ctx);
static void SolidColorLexerFree(pSolidColorLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
SolidColorLexerFree  (pSolidColorLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
SolidColorLexerReset (pSolidColorLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SolidColor.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
    return fileName;
}

/** \brief Create a new lexer called SolidColorLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSolidColorLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSolidColorLexer SolidColorLexerNew
(pANTLR3_INPUT_STREAM instream)
{
    // See if we can create a new lexer with the standard constructor
    //
    return SolidColorLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called SolidColorLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSolidColorLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSolidColorLexer SolidColorLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSolidColorLexer ctx; // Context structure we will build and return

    ctx = (pSolidColorLexer) ANTLR3_CALLOC(1, sizeof(SolidColorLexer));

    if  (ctx == NULL) {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SolidColorLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer = antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if  (ctx->pLexer == NULL) {
        ANTLR3_FREE(ctx);
        return  NULL;
    }
    /* Install the implementation of our SolidColorLexer interface
     */
    ctx->mT__15 = mT__15;
    ctx->mT__16 = mT__16;
    ctx->mT__17 = mT__17;
    ctx->mT__18 = mT__18;
    ctx->mID    = mID;
    ctx->mHEXINT    = mHEXINT;
    ctx->mFLOAT = mFLOAT;
    ctx->mCOMMENT   = mCOMMENT;
    ctx->mWS    = mWS;
    ctx->mSTRING    = mSTRING;
    ctx->mEXPONENT  = mEXPONENT;
    ctx->mHEX_DIGIT = mHEX_DIGIT;
    ctx->mESC_SEQ   = mESC_SEQ;
    ctx->mOCTAL_ESC = mOCTAL_ESC;
    ctx->mUNICODE_ESC   = mUNICODE_ESC;
    ctx->mTokens    = mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx        = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName = getGrammarFileName;
    ctx->free       = SolidColorLexerFree;
    ctx->reset          = SolidColorLexerReset;





    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    54:1: FLOAT : ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ ( EXPONENT )? );
 */
static const ANTLR3_INT32 dfa14_eot[6] = {
    -1, -1, 5, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_eof[6] = {
    -1, -1, -1, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_min[6] = {
    45, 46, 46, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_max[6] = {
    57, 57, 57, -1, -1, -1
};
static const ANTLR3_INT32 dfa14_accept[6] = {
    -1, -1, -1, 2, 1, 3
};
static const ANTLR3_INT32 dfa14_special[6] = {
    -1, -1, -1, -1, -1, -1
};

/** Used when there is no transition table entry for a particular state */
#define dfa14_T_empty       NULL

static const ANTLR3_INT32 dfa14_T0[] = {
    4, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};
static const ANTLR3_INT32 dfa14_T1[] = {
    1, 3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};
static const ANTLR3_INT32 dfa14_T2[] = {
    3, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
};

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa14_transitions[] = {
    dfa14_T1, dfa14_T2, dfa14_T0, dfa14_T_empty, dfa14_T_empty, dfa14_T_empty
};


/* Declare tracking structure for Cyclic DFA 14
 */
static
ANTLR3_CYCLIC_DFA cdfa14
=   {
    14,         /* Decision number of this dfa      */
    /* Which decision this represents:   */
    (const pANTLR3_UCHAR)"54:1: FLOAT : ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ ( EXPONENT )? );",
    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,    /* Default special state transition function    */
    antlr3dfaspecialTransition,     /* DFA specialTransition is currently just a default function in the runtime */
    antlr3dfapredict,           /* DFA simulator function is in the runtime */
    dfa14_eot,      /* EOT table                */
    dfa14_eof,      /* EOF table                */
    dfa14_min,      /* Minimum tokens for each state    */
    dfa14_max,      /* Maximum tokens for each state    */
    dfa14_accept,   /* Accept table             */
    dfa14_special,  /* Special transition states        */
    dfa14_transitions   /* Table of transition tables       */

};
/* End of Cyclic DFA 14
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 19:7: ( 'rgba(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__15
 *
 * Looks to match the characters the constitute the token T__15
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__15(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__15;


    // SolidColor.g:19:7: ( 'rgba(' )
    // SolidColor.g:19:9: 'rgba('
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION()) {
            goto ruleT__15Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__15Ex; /* Prevent compiler warnings */
ruleT__15Ex:
    ;

}
// $ANTLR end T__15

//   Comes from: 20:7: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__16
 *
 * Looks to match the characters the constitute the token T__16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__16(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__16;


    // SolidColor.g:20:7: ( ',' )
    // SolidColor.g:20:9: ','
    {
        MATCHC(',');
        if  (HASEXCEPTION()) {
            goto ruleT__16Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__16Ex; /* Prevent compiler warnings */
ruleT__16Ex:
    ;

}
// $ANTLR end T__16

//   Comes from: 21:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__17
 *
 * Looks to match the characters the constitute the token T__17
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__17(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__17;


    // SolidColor.g:21:7: ( ')' )
    // SolidColor.g:21:9: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION()) {
            goto ruleT__17Ex;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__17Ex; /* Prevent compiler warnings */
ruleT__17Ex:
    ;

}
// $ANTLR end T__17

//   Comes from: 22:7: ( 'hsba(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__18
 *
 * Looks to match the characters the constitute the token T__18
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__18(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = T__18;


    // SolidColor.g:22:7: ( 'hsba(' )
    // SolidColor.g:22:9: 'hsba('
    {
        MATCHS(lit_2);
        if  (HASEXCEPTION()) {
            goto ruleT__18Ex;
        }



    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__18Ex; /* Prevent compiler warnings */
ruleT__18Ex:
    ;

}
// $ANTLR end T__18

//   Comes from: 46:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = ID;


    // SolidColor.g:46:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
    // SolidColor.g:46:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIDEx;
        }


        // SolidColor.g:46:31: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

        for (;;) {
            int alt1 = 2;
            switch ( LA(1) ) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z': {
                alt1 = 1;
            }
            break;

            }

            switch (alt1) {
            case 1:
                // SolidColor.g:
            {
                if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleIDEx;
                }


            }
            break;

            default:
                goto loop1; /* break out of the loop */
                break;
            }
        }
loop1: ; /* Jump out to here if this rule does not match */


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
ruleIDEx:
    ;

}
// $ANTLR end ID

//   Comes from: 52:9: ( ( '0x' | '#' ) ( HEX_DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEXINT
 *
 * Looks to match the characters the constitute the token HEXINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEXINT(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = HEXINT;


    // SolidColor.g:52:9: ( ( '0x' | '#' ) ( HEX_DIGIT )+ )
    // SolidColor.g:52:11: ( '0x' | '#' ) ( HEX_DIGIT )+
    {

        // SolidColor.g:52:11: ( '0x' | '#' )
        {
            int alt2 = 2;
            switch ( LA(1) ) {
            case '0': {
                alt2 = 1;
            }
            break;
            case '#': {
                alt2 = 2;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleHEXINTEx;
            }

            switch (alt2) {
            case 1:
                // SolidColor.g:52:12: '0x'
            {
                MATCHS(lit_3);
                if  (HASEXCEPTION()) {
                    goto ruleHEXINTEx;
                }



            }
            break;
            case 2:
                // SolidColor.g:52:19: '#'
            {
                MATCHC('#');
                if  (HASEXCEPTION()) {
                    goto ruleHEXINTEx;
                }


            }
            break;

            }
        }
        // SolidColor.g:52:24: ( HEX_DIGIT )+
        {
            int cnt3 = 0;

            for (;;) {
                int alt3 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f': {
                    alt3 = 1;
                }
                break;

                }

                switch (alt3) {
                case 1:
                    // SolidColor.g:52:24: HEX_DIGIT
                {
                    /* 52:24: HEX_DIGIT */
                    mHEX_DIGIT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleHEXINTEx;
                    }


                }
                break;

                default:

                    if ( cnt3 >= 1 ) {
                        goto loop3;
                    }
                    /* mismatchedSetEx()
                     */
                    CONSTRUCTEX();
                    EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                    EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                    goto ruleHEXINTEx;
                }
                cnt3++;
            }
loop3: ;    /* Jump to here if this rule does not match */
        }

    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEXINTEx; /* Prevent compiler warnings */
ruleHEXINTEx:
    ;

}
// $ANTLR end HEXINT

//   Comes from: 55:5: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ ( EXPONENT )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = FLOAT;


    {
        //  SolidColor.g:55:5: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '-' )? ( '0' .. '9' )+ ( EXPONENT )? )

        ANTLR3_UINT32 alt14;

        alt14 = 3;

        alt14 = cdfa14.predict(ctx, RECOGNIZER, ISTREAM, &cdfa14);
        if  (HASEXCEPTION()) {
            goto ruleFLOATEx;
        }

        switch (alt14) {
        case 1:
            // SolidColor.g:55:9: ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
        {

            // SolidColor.g:55:9: ( '-' )?
            {
                int alt4 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt4 = 1;
                }
                break;
                }

                switch (alt4) {
                case 1:
                    // SolidColor.g:55:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            // SolidColor.g:55:14: ( '0' .. '9' )+
            {
                int cnt5 = 0;

                for (;;) {
                    int alt5 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt5 = 1;
                    }
                    break;

                    }

                    switch (alt5) {
                    case 1:
                        // SolidColor.g:55:15: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt5 >= 1 ) {
                            goto loop5;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt5++;
                }
loop5: ;    /* Jump to here if this rule does not match */
            }
            MATCHC('.');
            if  (HASEXCEPTION()) {
                goto ruleFLOATEx;
            }


            // SolidColor.g:55:30: ( '0' .. '9' )*

            for (;;) {
                int alt6 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    alt6 = 1;
                }
                break;

                }

                switch (alt6) {
                case 1:
                    // SolidColor.g:55:31: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                default:
                    goto loop6; /* break out of the loop */
                    break;
                }
            }
loop6: ; /* Jump out to here if this rule does not match */


            // SolidColor.g:55:42: ( EXPONENT )?
            {
                int alt7 = 2;
                switch ( LA(1) ) {
                case 'E':
                case 'e': {
                    alt7 = 1;
                }
                break;
                }

                switch (alt7) {
                case 1:
                    // SolidColor.g:55:42: EXPONENT
                {
                    /* 55:42: EXPONENT */
                    mEXPONENT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }

        }
        break;
        case 2:
            // SolidColor.g:56:9: ( '-' )? '.' ( '0' .. '9' )+ ( EXPONENT )?
        {

            // SolidColor.g:56:9: ( '-' )?
            {
                int alt8 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt8 = 1;
                }
                break;
                }

                switch (alt8) {
                case 1:
                    // SolidColor.g:56:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            MATCHC('.');
            if  (HASEXCEPTION()) {
                goto ruleFLOATEx;
            }

            // SolidColor.g:56:18: ( '0' .. '9' )+
            {
                int cnt9 = 0;

                for (;;) {
                    int alt9 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt9 = 1;
                    }
                    break;

                    }

                    switch (alt9) {
                    case 1:
                        // SolidColor.g:56:19: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt9 >= 1 ) {
                            goto loop9;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt9++;
                }
loop9: ;    /* Jump to here if this rule does not match */
            }

            // SolidColor.g:56:30: ( EXPONENT )?
            {
                int alt10 = 2;
                switch ( LA(1) ) {
                case 'E':
                case 'e': {
                    alt10 = 1;
                }
                break;
                }

                switch (alt10) {
                case 1:
                    // SolidColor.g:56:30: EXPONENT
                {
                    /* 56:30: EXPONENT */
                    mEXPONENT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }

        }
        break;
        case 3:
            // SolidColor.g:57:9: ( '-' )? ( '0' .. '9' )+ ( EXPONENT )?
        {

            // SolidColor.g:57:9: ( '-' )?
            {
                int alt11 = 2;
                switch ( LA(1) ) {
                case '-': {
                    alt11 = 1;
                }
                break;
                }

                switch (alt11) {
                case 1:
                    // SolidColor.g:57:9: '-'
                {
                    MATCHC('-');
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }
            // SolidColor.g:57:14: ( '0' .. '9' )+
            {
                int cnt12 = 0;

                for (;;) {
                    int alt12 = 2;
                    switch ( LA(1) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9': {
                        alt12 = 1;
                    }
                    break;

                    }

                    switch (alt12) {
                    case 1:
                        // SolidColor.g:57:15: '0' .. '9'
                    {
                        MATCHRANGE('0', '9');
                        if  (HASEXCEPTION()) {
                            goto ruleFLOATEx;
                        }


                    }
                    break;

                    default:

                        if ( cnt12 >= 1 ) {
                            goto loop12;
                        }
                        /* mismatchedSetEx()
                         */
                        CONSTRUCTEX();
                        EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                        EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                        goto ruleFLOATEx;
                    }
                    cnt12++;
                }
loop12: ;   /* Jump to here if this rule does not match */
            }

            // SolidColor.g:57:26: ( EXPONENT )?
            {
                int alt13 = 2;
                switch ( LA(1) ) {
                case 'E':
                case 'e': {
                    alt13 = 1;
                }
                break;
                }

                switch (alt13) {
                case 1:
                    // SolidColor.g:57:26: EXPONENT
                {
                    /* 57:26: EXPONENT */
                    mEXPONENT(ctx );
                    if  (HASEXCEPTION()) {
                        goto ruleFLOATEx;
                    }


                }
                break;

                }
            }

        }
        break;

        }
    }
    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
ruleFLOATEx:
    ;

}
// $ANTLR end FLOAT

//   Comes from: 61:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = COMMENT;


    {
        //  SolidColor.g:61:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR3_UINT32 alt18;

        alt18 = 2;

        switch ( LA(1) ) {
        case '/': {
            switch ( LA(2) ) {
            case '/': {
                alt18 = 1;
            }
            break;
            case '*': {
                alt18 = 2;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 1;


                goto ruleCOMMENTEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 18;
            EXCEPTION->state        = 0;


            goto ruleCOMMENTEx;
        }

        switch (alt18) {
        case 1:
            // SolidColor.g:61:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
        {
            MATCHS(lit_4);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }



            // SolidColor.g:61:14: (~ ( '\\n' | '\\r' ) )*

            for (;;) {
                int alt15 = 2;
                {
                    /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    int LA15_0 = LA(1);
                    if ( (((LA15_0 >= 0x0000) && (LA15_0 <= '\t')) || ((LA15_0 >= 0x000B) && (LA15_0 <= '\f')) || ((LA15_0 >= 0x000E) && (LA15_0 <= 0xFFFF)))) {
                        alt15 = 1;
                    }

                }
                switch (alt15) {
                case 1:
                    // SolidColor.g:61:14: ~ ( '\\n' | '\\r' )
                {
                    if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) ) {
                        CONSUME();

                    } else {
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                        EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                        LRECOVER();
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                default:
                    goto loop15;    /* break out of the loop */
                    break;
                }
            }
loop15: ; /* Jump out to here if this rule does not match */


            // SolidColor.g:61:28: ( '\\r' )?
            {
                int alt16 = 2;
                switch ( LA(1) ) {
                case '\r': {
                    alt16 = 1;
                }
                break;
                }

                switch (alt16) {
                case 1:
                    // SolidColor.g:61:28: '\\r'
                {
                    MATCHC('\r');
                    if  (HASEXCEPTION()) {
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                }
            }
            MATCHC('\n');
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }

            {
                LEXSTATE->channel = HIDDEN;
            }

        }
        break;
        case 2:
            // SolidColor.g:62:9: '/*' ( options {greedy=false; } : . )* '*/'
        {
            MATCHS(lit_5);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }



            // SolidColor.g:62:14: ( options {greedy=false; } : . )*

            for (;;) {
                int alt17 = 2;
                {
                    /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                     */
                    int LA17_0 = LA(1);
                    if ( (LA17_0 == '*')) {
                        {
                            /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                             */
                            int LA17_1 = LA(2);
                            if ( (LA17_1 == '/')) {
                                alt17 = 2;
                            } else if ( (((LA17_1 >= 0x0000) && (LA17_1 <= '.')) || ((LA17_1 >= '0') && (LA17_1 <= 0xFFFF)))) {
                                alt17 = 1;
                            }

                        }
                    } else if ( (((LA17_0 >= 0x0000) && (LA17_0 <= ')')) || ((LA17_0 >= '+') && (LA17_0 <= 0xFFFF)))) {
                        alt17 = 1;
                    }

                }
                switch (alt17) {
                case 1:
                    // SolidColor.g:62:42: .
                {
                    MATCHANY();
                    if  (HASEXCEPTION()) {
                        goto ruleCOMMENTEx;
                    }


                }
                break;

                default:
                    goto loop17;    /* break out of the loop */
                    break;
                }
            }
loop17: ; /* Jump out to here if this rule does not match */

            MATCHS(lit_6);
            if  (HASEXCEPTION()) {
                goto ruleCOMMENTEx;
            }


            {
                LEXSTATE->channel = HIDDEN;
            }

        }
        break;

        }
    }
    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
ruleCOMMENTEx:
    ;

}
// $ANTLR end COMMENT

//   Comes from: 65:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = WS;


    // SolidColor.g:65:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
    // SolidColor.g:65:9: ( ' ' | '\\t' | '\\r' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWSEx;
        }

        {
            LEXSTATE->channel = HIDDEN;
        }

    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
ruleWSEx:
    ;

}
// $ANTLR end WS

//   Comes from: 73:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;

    _type       = STRING;


    // SolidColor.g:73:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // SolidColor.g:73:8: '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION()) {
            goto ruleSTRINGEx;
        }


        // SolidColor.g:73:13: ( ESC_SEQ | ~ ( '\\\\' | '\\'' ) )*

        for (;;) {
            int alt19 = 3;
            {
                /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                 */
                int LA19_0 = LA(1);
                if ( (LA19_0 == '\\')) {
                    alt19 = 1;
                } else if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '&')) || ((LA19_0 >= '(') && (LA19_0 <= '[')) || ((LA19_0 >= ']') && (LA19_0 <= 0xFFFF)))) {
                    alt19 = 2;
                }

            }
            switch (alt19) {
            case 1:
                // SolidColor.g:73:15: ESC_SEQ
            {
                /* 73:15: ESC_SEQ */
                mESC_SEQ(ctx );
                if  (HASEXCEPTION()) {
                    goto ruleSTRINGEx;
                }


            }
            break;
            case 2:
                // SolidColor.g:73:25: ~ ( '\\\\' | '\\'' )
            {
                if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleSTRINGEx;
                }


            }
            break;

            default:
                goto loop19;    /* break out of the loop */
                break;
            }
        }
loop19: ; /* Jump out to here if this rule does not match */

        MATCHC('\'');
        if  (HASEXCEPTION()) {
            goto ruleSTRINGEx;
        }


    }

    LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
ruleSTRINGEx:
    ;

}
// $ANTLR end STRING

//   Comes from: 77:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;


    // SolidColor.g:77:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // SolidColor.g:77:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXPONENTEx;
        }


        // SolidColor.g:77:22: ( '+' | '-' )?
        {
            int alt20 = 2;
            switch ( LA(1) ) {
            case '+':
            case '-': {
                alt20 = 1;
            }
            break;
            }

            switch (alt20) {
            case 1:
                // SolidColor.g:
            {
                if ( LA(1) == '+' || LA(1) == '-' ) {
                    CONSUME();

                } else {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                    LRECOVER();
                    goto ruleEXPONENTEx;
                }


            }
            break;

            }
        }
        // SolidColor.g:77:33: ( '0' .. '9' )+
        {
            int cnt21 = 0;

            for (;;) {
                int alt21 = 2;
                switch ( LA(1) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9': {
                    alt21 = 1;
                }
                break;

                }

                switch (alt21) {
                case 1:
                    // SolidColor.g:77:34: '0' .. '9'
                {
                    MATCHRANGE('0', '9');
                    if  (HASEXCEPTION()) {
                        goto ruleEXPONENTEx;
                    }


                }
                break;

                default:

                    if ( cnt21 >= 1 ) {
                        goto loop21;
                    }
                    /* mismatchedSetEx()
                     */
                    CONSTRUCTEX();
                    EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                    EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                    goto ruleEXPONENTEx;
                }
                cnt21++;
            }
loop21: ;   /* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
ruleEXPONENTEx:
    ;

}
// $ANTLR end EXPONENT

//   Comes from: 80:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;


    // SolidColor.g:80:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // SolidColor.g:80:13: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) ) {
            CONSUME();

        } else {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
ruleHEX_DIGITEx:
    ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 84:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC_SEQ
 *
 * Looks to match the characters the constitute the token ESC_SEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESC_SEQ(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;


    {
        //  SolidColor.g:84:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )

        ANTLR3_UINT32 alt22;

        alt22 = 3;

        switch ( LA(1) ) {
        case '\\': {
            switch ( LA(2) ) {
            case '"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't': {
                alt22 = 1;
            }
            break;
            case 'u': {
                alt22 = 2;
            }
            break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7': {
                alt22 = 3;
            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 1;


                goto ruleESC_SEQEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 22;
            EXCEPTION->state        = 0;


            goto ruleESC_SEQEx;
        }

        switch (alt22) {
        case 1:
            // SolidColor.g:84:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }

            if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' ) {
                CONSUME();

            } else {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

                LRECOVER();
                goto ruleESC_SEQEx;
            }


        }
        break;
        case 2:
            // SolidColor.g:85:9: UNICODE_ESC
        {
            /* 85:9: UNICODE_ESC */
            mUNICODE_ESC(ctx );
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }


        }
        break;
        case 3:
            // SolidColor.g:86:9: OCTAL_ESC
        {
            /* 86:9: OCTAL_ESC */
            mOCTAL_ESC(ctx );
            if  (HASEXCEPTION()) {
                goto ruleESC_SEQEx;
            }


        }
        break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESC_SEQEx; /* Prevent compiler warnings */
ruleESC_SEQEx:
    ;

}
// $ANTLR end ESC_SEQ

//   Comes from: 91:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESC
 *
 * Looks to match the characters the constitute the token OCTAL_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESC(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;


    {
        //  SolidColor.g:91:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )

        ANTLR3_UINT32 alt23;

        alt23 = 3;

        switch ( LA(1) ) {
        case '\\': {
            switch ( LA(2) ) {
            case '0':
            case '1':
            case '2':
            case '3': {
                switch ( LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    switch ( LA(4) ) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7': {
                        alt23 = 1;
                    }
                    break;

                    default:
                        alt23 = 2;
                    }

                }
                break;

                default:
                    alt23 = 3;
                }

            }
            break;
            case '4':
            case '5':
            case '6':
            case '7': {
                switch ( LA(3) ) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    alt23 = 2;
                }
                break;

                default:
                    alt23 = 3;
                }

            }
            break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 1;


                goto ruleOCTAL_ESCEx;
            }

        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 23;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCEx;
        }

        switch (alt23) {
        case 1:
            // SolidColor.g:91:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // SolidColor.g:91:14: ( '0' .. '3' )
            // SolidColor.g:91:15: '0' .. '3'
            {
                MATCHRANGE('0', '3');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // SolidColor.g:91:25: ( '0' .. '7' )
            // SolidColor.g:91:26: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // SolidColor.g:91:36: ( '0' .. '7' )
            // SolidColor.g:91:37: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;
        case 2:
            // SolidColor.g:92:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // SolidColor.g:92:14: ( '0' .. '7' )
            // SolidColor.g:92:15: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }

            // SolidColor.g:92:25: ( '0' .. '7' )
            // SolidColor.g:92:26: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;
        case 3:
            // SolidColor.g:93:9: '\\\\' ( '0' .. '7' )
        {
            MATCHC('\\');
            if  (HASEXCEPTION()) {
                goto ruleOCTAL_ESCEx;
            }

            // SolidColor.g:93:14: ( '0' .. '7' )
            // SolidColor.g:93:15: '0' .. '7'
            {
                MATCHRANGE('0', '7');
                if  (HASEXCEPTION()) {
                    goto ruleOCTAL_ESCEx;
                }


            }


        }
        break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCEx; /* Prevent compiler warnings */
ruleOCTAL_ESCEx:
    ;

}
// $ANTLR end OCTAL_ESC

//   Comes from: 98:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESC
 *
 * Looks to match the characters the constitute the token UNICODE_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESC(pSolidColorLexer ctx)
{
    ANTLR3_UINT32   _type;


    // SolidColor.g:98:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // SolidColor.g:98:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\');
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        MATCHC('u');
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 98:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 98:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 98:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }

        /* 98:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION()) {
            goto ruleUNICODE_ESCEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCEx; /* Prevent compiler warnings */
ruleUNICODE_ESCEx:
    ;

}
// $ANTLR end UNICODE_ESC

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pSolidColorLexer ctx)
{
    {
        //  SolidColor.g:1:8: ( T__15 | T__16 | T__17 | T__18 | ID | HEXINT | FLOAT | COMMENT | WS | STRING )

        ANTLR3_UINT32 alt24;

        alt24 = 10;

        switch ( LA(1) ) {
        case 'r': {
            switch ( LA(2) ) {
            case 'g': {
                switch ( LA(3) ) {
                case 'b': {
                    switch ( LA(4) ) {
                    case 'a': {
                        switch ( LA(5) ) {
                        case '(': {
                            alt24 = 1;
                        }
                        break;

                        default:
                            alt24 = 5;
                        }

                    }
                    break;

                    default:
                        alt24 = 5;
                    }

                }
                break;

                default:
                    alt24 = 5;
                }

            }
            break;

            default:
                alt24 = 5;
            }

        }
        break;
        case ',': {
            alt24 = 2;
        }
        break;
        case ')': {
            alt24 = 3;
        }
        break;
        case 'h': {
            switch ( LA(2) ) {
            case 's': {
                switch ( LA(3) ) {
                case 'b': {
                    switch ( LA(4) ) {
                    case 'a': {
                        switch ( LA(5) ) {
                        case '(': {
                            alt24 = 4;
                        }
                        break;

                        default:
                            alt24 = 5;
                        }

                    }
                    break;

                    default:
                        alt24 = 5;
                    }

                }
                break;

                default:
                    alt24 = 5;
                }

            }
            break;

            default:
                alt24 = 5;
            }

        }
        break;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '_':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z': {
            alt24 = 5;
        }
        break;
        case '0': {
            switch ( LA(2) ) {
            case 'x': {
                alt24 = 6;
            }
            break;

            default:
                alt24 = 7;
            }

        }
        break;
        case '#': {
            alt24 = 6;
        }
        break;
        case '-':
        case '.':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': {
            alt24 = 7;
        }
        break;
        case '/': {
            alt24 = 8;
        }
        break;
        case '\t':
        case '\n':
        case '\r':
        case ' ': {
            alt24 = 9;
        }
        break;
        case '\'': {
            alt24 = 10;
        }
        break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 24;
            EXCEPTION->state        = 0;


            goto ruleTokensEx;
        }

        switch (alt24) {
        case 1:
            // SolidColor.g:1:10: T__15
        {
            /* 1:10: T__15 */
            mT__15(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 2:
            // SolidColor.g:1:16: T__16
        {
            /* 1:16: T__16 */
            mT__16(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 3:
            // SolidColor.g:1:22: T__17
        {
            /* 1:22: T__17 */
            mT__17(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 4:
            // SolidColor.g:1:28: T__18
        {
            /* 1:28: T__18 */
            mT__18(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 5:
            // SolidColor.g:1:34: ID
        {
            /* 1:34: ID */
            mID(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 6:
            // SolidColor.g:1:37: HEXINT
        {
            /* 1:37: HEXINT */
            mHEXINT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 7:
            // SolidColor.g:1:44: FLOAT
        {
            /* 1:44: FLOAT */
            mFLOAT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 8:
            // SolidColor.g:1:50: COMMENT
        {
            /* 1:50: COMMENT */
            mCOMMENT(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 9:
            // SolidColor.g:1:58: WS
        {
            /* 1:58: WS */
            mWS(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;
        case 10:
            // SolidColor.g:1:61: STRING
        {
            /* 1:61: STRING */
            mSTRING(ctx );
            if  (HASEXCEPTION()) {
                goto ruleTokensEx;
            }


        }
        break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx:
    ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
